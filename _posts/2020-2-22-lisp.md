---
layout: post
title: ç”¨Lispå†™ä¸€ä¸ªè§£é‡Šå™¨
summary: Schemeçš„ç‰¹ç‚¹ -> Schemeå·¥ç¨‹å¼€å‘çš„é—®é¢˜ -> å¦‚ä½•å†™è§£é‡Šå™¨
featured-img: lisp
---

## TL; DR

+ Schemeçš„ç‰¹ç‚¹
  + è¯­æ³•ç®€æ´ç»Ÿä¸€
  + é¢å‘æ±‚å€¼
  + é€’å½’
  + åŒèŒƒå¼
  + è¯­æ³•å¹¶ä¸æ˜¯ç»å¯¹ç»Ÿä¸€
  + Metaprogramming & S-expression
  + Continuation
  + Hygienic Macro
+ Schemeä¸é€‚åˆå·¥ç¨‹å¼€å‘
  + æ— æ‹¿å¾—å‡ºæ‰‹çš„å¼€å‘å·¥å…·
  + ç”Ÿæ€å·®
  + åŠ¨æ€ç±»å‹
  + ä»£ç éš¾ä»¥ç”¨è‚‰çœ¼parse
  + ChezScheme debugåäººç±»
+ å¦‚ä½•å†™è§£é‡Šå™¨
  + Lexer => Parser => Interpreter
  + Lexical scoping
  + immutableå®ç°mutableçš„é—®é¢˜
  + æ­£åˆ™åºå’Œåº”ç”¨åº

***

## Schemeçš„ç‰¹ç‚¹

### è¯­æ³•ç®€æ´ç»Ÿä¸€

è¯­æ³•é‡‡ç”¨S-expressionï¼Œæ‰€æœ‰è¯­æ³•å…ƒç´ éƒ½æ˜¯å¹¿ä¹‰è¡¨

æ•°å­—è¿ç®—ä½¿ç”¨å‰ç¼€è¡¨è¾¾å¼ï¼Œè¿™æ ·å°±å¯ä»¥æŠŠæ‰€æœ‰çš„è¿ç®—ç¬¦å½“ä½œå‡½æ•°ï¼Œä¹Ÿå°±å¯ä»¥æ¶ˆé™¤è¿ç®—ç¬¦è¿™ä¸ªæ¦‚å¿µ

æ•´ä½“çš„è¯­æ³•ç®€æ´ç»Ÿä¸€ï¼Œä¸ä¸¾ä¾‹äº†ï¼Œè¯¦è§rnrs

### é¢å‘æ±‚å€¼

è¯­å¥éƒ½æœ‰è¿”å›å€¼ï¼ˆè¯­å¥è€Œä¸æ˜¯å‡½æ•°ï¼‰ï¼Œå‡½æ•°è¿”å›å€¼ä¸ºæœ€åä¸€æ¡è¯­å¥è®¡ç®—çš„å€¼

```lisp
(define foo (if #t 1 2))
```

### é€’å½’

æ— `for`, `while`ç­‰å¾ªç¯è¯­å¥ï¼Œç”¨é€’å½’æ›¿ä»£å¾ªç¯ã€‚rnrsè¦æ±‚å¿…éœ€å®ç°ä¸¥æ ¼å°¾é€’å½’ä¼˜åŒ–ï¼Œæ‰€ä»¥åªè¦ä»£ç å†™çš„æ²¡é—®é¢˜ä¸€èˆ¬ä¸ä¼šå‡ºç°OOM

ä¹ æƒ¯ç”¨named-letå®ç°å¾ªç¯

```lisp
(let loop ((lst lst))
  (if (null? lst)
    'end
    (let ((ele (car lst)))
      (printf "~s\n" ele)
      (loop (cdr lst)))))
```

### åŒèŒƒå¼

Schemeå¹¶ä¸åƒä¼ ç»Ÿå‡½æ•°å¼è¯­è¨€ä¸€æ ·åªæœ‰å‡½æ•°å¼æ•°æ®ç»“æ„ï¼Œå®ƒè¿˜æä¾›äº†`set!`

åŒ…æ‹¬`record`ç±»å‹å¯ä»¥å£°æ˜å¯å˜å­—æ®µ

```lisp
(define-record-type foo (fields (mutable x)))
(define f (make-foo 1))
(foo-x-set! f 2)
```

è¿˜æœ‰æ˜¾å¾—å®Œå…¨ä¹±å…¥çš„hashtableï¼Œ`list`, `vector`ç­‰å…¶å®ƒå¤åˆç±»å‹å®ç°ä¸äº†ä¸‹é¢çš„ä¾‹å­

```lisp
(define h (make-eq-hashtable))
(define lst `(,h))
(hashtable-set! (car lst) 'k 'v)
(eq? (hashtable-ref h 'k 'null)
     (hashtable-ref h 'k 'null))
```

### è¯­æ³•å¹¶ä¸æ˜¯ç»å¯¹ç»Ÿä¸€

è¯­æ³•ä¸­æœ‰ä¸€ä¸ªå…ƒç´ å«`form`

```lisp
(case 1
  (1 '1))
  
(case 1
  ((1) '1))
  
(define fn (lambda () 1))

(case 1
  (fn '1))
  
(case 1
  ((fn) '1))
  
(case 1
  (((fn)) '1))
```

æ­§ä¹‰å‡ºç°äº†

åˆæˆ–è€…è¯´`cond`çš„è¯­æ³•ï¼ˆæˆ‘ä¸ªäººæ›´æ„¿æ„ç”¨`cond`ä»£æ›¿`if`ï¼‰ï¼š

```lisp
(if 1
  (begin
    (display 1)
    (display 2))
  (begin
    (display 3)
    (display 4)))
    
(cond
  ((= 1 1) (display 1)
           (display 2))
  (else (display 1)
        (display 2)))
```

çœ‹åˆ°äº†å—ï¼Œå› ä¸º`if`çš„è¯­æ³•é™åˆ¶å¯¼è‡´å¤šæ¡è¯­å¥ä¸­å¿…é¡»ä½¿ç”¨`begin`ï¼Œè€Œä¸èƒ½ç›´æ¥`((display 1) (display 2))`ï¼Œå¦‚æœè¿™æ ·å†™å®é™…çš„æ±‚å€¼é¡ºåºä¹Ÿæ˜¯UBï¼š

```lisp
> (if #t ((display 1) (display 2)) 'F)
21
```

è€Œåœ¨`cond`é‡Œï¼Œæ¯ä¸€ä¸ªconditionçš„bodyä¸­éƒ½å¯ä»¥æ·»åŠ éšæ„æ•°é‡çš„è¯­å¥ï¼Œæ‰€ä»¥åœ¨ä¿æŒè¯­æ³•ç»Ÿä¸€ä¸Šï¼Œcondæ›´ä¼˜ã€‚ä½†å®é™…ä¸ŠæŸäº›Schemeå®ç°é‡Œä¼šç”¨ifæ¥å®ç°cond

### Metaprogramming & S-expression

Schemeä¸­ä»£ç ä¸æ•°æ®éƒ½æ˜¯S-expression

```lisp
(define code '(display 1))
(eval code)
```

å¾—ç›Šäºè¯­æ³•çš„ç»Ÿä¸€ï¼Œä»£ç æ•°æ®æ²¡æœ‰ç»å¯¹çš„ç•Œé™

### Continuation

ä¸­æ–‡è¯‘ä¸ºå»¶ç»­ï¼Œè§£é‡Šä¸ºï¼š

> During the evaluation of a Scheme expression, the implementation must keep track of two things: (1) what to evaluate and (2) what to do with the value. ... We call "what to do with the value" the *continuation* of a computation.

continuationæ¶‰åŠåˆ°CPS(Continuation-Passing-Style)é£æ ¼ï¼Œæ­¤å¤„ä¸è¯¦ç»†ä»‹ç»

è¯´ç™½äº†ï¼Œå°±æ˜¯å°†evaluationæ—¶çš„ç¯å¢ƒå’Œåç»­è®¡ç®—æ‰“åŒ…ä¿å­˜ä¸‹æ¥

```lisp
(* 3 (call/cc 
       (lambda (k)
         (k 2))))
```

continuationå¯ä»¥å®ç°generatorï¼Œä¹Ÿå°±æ˜¯åƒPythonä¸­yieldçš„è¯­æ³•ï¼Œè¿›è€Œå®ç°coroutine

å‡å¦‚è¯´è¦ç”¨pure Cå®ç°ï¼Œæ˜¯ä¸å¯èƒ½çš„ã€‚å› ä¸ºCè¯­è¨€ä¸­å‡½æ•°è¿”å›æ§åˆ¶æƒåªèƒ½æ˜¯returnåï¼Œä¹Ÿå°±æ„å‘³ç€å‡½æ•°æ ˆå¸§é”€æ¯äº†ã€‚æ‰€ä»¥æƒ³å®ç°åªèƒ½åœ¨æ±‡ç¼–å±‚é¢ï¼Œå°†å±€éƒ¨å˜é‡ä»¥åŠæ‰§è¡Œä½ç½®å­˜å…¥å¯„å­˜å™¨ã€‚`ucontext.h`å’Œ`longjmp/setjmp`å°±æ˜¯è¿™æ ·å®ç°çš„

åœ¨Schemeä¸­ï¼Œå¾—ç›Šäºcontinuationæ˜¯ä¸ªä¸€çº§å¯¹è±¡ï¼Œå¯ä»¥åˆ©ç”¨å®ƒæ¥å®ç°coroutine

```lisp
;; http://deathking.github.io/yast-cn/contents/chapter16.html
;; abbreviation
(define call/cc call-with-current-continuation)

;; queue
(define (make-queue)
  (cons '() '()))

(define (enqueue! queue obj)
  (let ((lobj (list obj)))
    (if (null? (car queue))
    (begin
      (set-car! queue lobj)
      (set-cdr! queue lobj))
    (begin
      (set-cdr! (cdr queue) lobj)
      (set-cdr! queue lobj)))
    (car queue)))

(define (dequeue! queue)
  (let ((obj (car (car queue))))
    (set-car! queue (cdr (car queue)))
    obj))


;; coroutine   
(define process-queue (make-queue))

(define (coroutine thunk)
  (enqueue! process-queue thunk))

(define (start)
   ((dequeue! process-queue)))
   
(define (pause)
  (call/cc
   (lambda (k)
     (coroutine (lambda () (k #f)))
     (start))))


;; example
(coroutine (lambda ()
         (let loop ((i 0)) 
           (if (< i 10)
           (begin
             (display (1+ i)) 
             (display " ") 
             (pause) 
             (loop (1+ i)))))))
           
(coroutine (lambda ()
         (let loop ((i 0)) 
           (if (< i 10)
           (begin
             (display (integer->char (+ i 97)))
             (display " ")
             (pause) 
             (loop (1+ i)))))))

(newline)
(start)
```

### Hygienic Macro

è¯‘ä¸ºå«ç”Ÿå®ï¼Œä¸Cä¸­ä¸å«ç”Ÿçš„å®ä¸åŒï¼Œå«ç”Ÿå®å±•å¼€æ—¶ä¸ä¼šæ±¡æŸ“å‘½åç©ºé—´ï¼Œå³å˜é‡æ•è·æ˜¯æ²¡æœ‰é—®é¢˜çš„ï¼›è€Œä¸å«ç”Ÿå®å°±æ˜¯ä¸€ä¸ªç®€å•çš„æ–‡æœ¬æ›¿æ¢

```c
#define MACRO(foo) do {       \
    int bar = 1;              \
    printf("%d", foo * bar);  \
} while(0)

int main() {
    int foo = 2;
    int bar = 3;

    MACRO((bar + 1));
}
```

```lisp
(define-syntax macro
  (syntax-rules ()
    ((_ foo)
     (let ((bar 1))
       (display (* foo bar))))))

(define foo 2)
(define bar 3)
(macro (+ bar 1))
```

è¾“å‡ºåˆ†åˆ«ä¸º2å’Œ4ï¼Œè™½ç„¶Schemeçš„å®ä¹Ÿæ˜¯åœ¨ç¼–è¯‘å™¨å±•å¼€ï¼ŒåŠå±•å¼€æ—¶ä¸æ¶‰åŠæ±‚å€¼ï¼Œä½†`(macro (+ bar 1))`ä¸­barçš„å®šä¹‰æ¥æºäºè°ƒç”¨å¤„çš„scope

## Schemeä¸é€‚åˆå·¥ç¨‹å¼€å‘

### æ— æ‹¿å¾—å‡ºæ‰‹çš„å¼€å‘å·¥å…·

æˆ‘ç”¨vscæ’ä»¶`vscode-chez v0.1.2`ï¼ŒåŠŸèƒ½åŸºæœ¬åªæœ‰ä¸€äº›å¸¸è§ç»“æ„çš„snippetsï¼Œè¯¸å¦‚æ ¼å¼åŒ–ï¼Œå®šä¹‰è·³è½¬éƒ½æ²¡æœ‰ï¼Œè¿é«˜äº®ä¹Ÿæ˜¯ä¸ªæ®‹æ¬¡å“ï¼ˆå­—ç¬¦ä¸²ä¸­çš„æ³¨é‡Šç¬¦éƒ½è¢«è¯†åˆ«ä¸ºæ³¨é‡Šï¼‰

Schemeçš„S-expressionè§£æèµ·æ¥å¾ˆæ–¹ä¾¿ï¼Œä½†è¿˜æ˜¯æ²¡æœ‰äººåšå¼€å‘å·¥å…·ï¼Œä¹Ÿä»ä¾§é¢å°è¯äº†ç”Ÿæ€ä¸è¡Œ

### ç”Ÿæ€å·®

ä¸è¯´äº†ï¼Œä»€ä¹ˆè½®å­éƒ½è‡ªå·±é€ ã€‚å½“ç„¶ï¼Œè°ƒç”¨Cè¯­è¨€çš„é“¾æ¥åº“è¿˜æ˜¯æŒºæ–¹ä¾¿çš„ï¼Œæ‰€ä»¥å¾ˆå¤šSchemeåº“éƒ½æ˜¯ä»…ç”¨Schemeåšä¸Šå±‚æ¥å£

é’ˆå¯¹è¿™ä¸€ç‚¹ï¼ŒLispæ–¹è¨€ä¸­Clojureåº”è¯¥æ˜¯æœ€å¥½çš„é€‰æ‹©ï¼ŒCLä¹Ÿä¼šä¼˜äºScheme

### åŠ¨æ€ç±»å‹

ä¸å¤šè¯´ï¼ŒåŠ¨æ€ç±»å‹çš„é€šç—…

### ä»£ç éš¾ä»¥ç”¨è‚‰çœ¼parse

))))))))))))))))))))))))))))))))))))))

### ChezScheme debugåäººç±»

chezschemeæ˜¯ä¸€ä¸ªç¥ä¸€æ ·çš„ç¼–è¯‘å™¨ï¼Œç¼–è¯‘é€Ÿåº¦å’Œç¼–è¯‘ç”Ÿæˆçš„ä»£ç é€Ÿåº¦éƒ½å¾ˆå¿«ï¼Œè„šæœ¬è¯­è¨€ä¸­æ— å‹åŠ›åŠæ‰“luaã€‚ç‹å è¯´èƒ½åª²ç¾Cï¼Œè¿™ç‚¹å½“ç„¶ç”¨è„šè¶¾å¤´æƒ³éƒ½çŸ¥é“çœŸå‡

å¿«æ˜¯å®ƒçš„ä¼˜ç‚¹ï¼Œä½†æ˜¯ï¼Œ...ï¼Œå®ƒç¼–è¯‘åä»£ç ä¸­æ‰€æœ‰çš„runtime exceptionéƒ½æ²¡æœ‰è¡Œå·ï¼Œä¹Ÿå°±æ„å‘³ç€å†™å®Œäº†ä»£ç ï¼Œè¿è¡ŒåæŠ¥é”™ï¼Œä½†å®ƒä¸å‘Šè¯‰ä½ æ˜¯å“ªä¸€è¡Œï¼Œåˆæ²¡æœ‰åˆé€‚çš„debuggerï¼Œæ‰€ä»¥å°±å¾—åœ¨ç¨‹åºçš„æ‰§è¡Œæµä¸­printï¼Œ

## å¦‚ä½•å†™è§£é‡Šå™¨

åæ§½å®Œäº†ï¼Œè¯´è¯´å¦‚ä½•å†™è§£é‡Šå™¨å§

ç›®æ ‡æ˜¯ä½¿ç”¨Schemeå®Œæˆä¸€ä¸ªç±»Cè¯­è¨€çš„è§£é‡Šå™¨ï¼Œç‰¹æ€§æ˜¯ï¼š

+ åŠ¨æ€è¯­è¨€
+ å¼ºç±»å‹
+ lexical scoping
+ with class

repoåœ°å€æ˜¯`https://github.com/EddieIvan01/yakult`

ç”±äº2020å¹´æ–°å‹è‚ºç‚ï¼Œåœ¨å®¶ä¸ºæ¶ˆç£¨æ—¶é—´å¼€äº†å‘ï¼Œä¹‹åå‘ç°å·¥ä½œé‡å¤ªå¤§ï¼Œå†™èµ·æ¥å¿ƒç´¯ï¼Œäºæ˜¯ğŸ‘´æœæ–­å†³å®šæš‚å¼ƒå‘

### Lexer => Parser => Interpreter

**Lexer**å…¶å®å¾ˆç®€å•ï¼Œå°±æ˜¯ä¸€ä¸ªç®€å•çš„åˆ†è¯å™¨ï¼Œå»æ‰ç©ºæ ¼æ³¨é‡Šæ¢è¡Œä¹‹ç±»çš„ï¼Œå°†æºç è§£æä¸ºtokenæµå³å¯ï¼Œä¸€ä¸ªæœ‰é™çŠ¶æ€æœºå³å¯æå®šï¼ˆæˆ–è€…ç”¨regexpæ¥åšä¹Ÿå¯ä»¥ï¼Œä½†ä¼šåšä¸å¿…è¦çš„å›æº¯æŸå¤±æ€§èƒ½ï¼‰

æˆ‘åœ¨è§£ææ—¶ç»´æŠ¤ä¸€ä¸ªpointeræ¥é€’å½’ï¼Œè¿™æ ·å°±å¯ä»¥æ–¹ä¾¿çš„ä»»æ„ç§»åŠ¨ã€‚è€Œå¦‚æœç”¨`car/cdr`æ¥åšé€’å½’çš„è¯ï¼Œå°±æ¯”è¾ƒéº»çƒ¦äº†

yakulté‡Œçš„åˆ†è¯é˜¶æ®µæŠŠæ‰€æœ‰çš„ç‰¹æ®Šç¬¦å·å½’ç±»åˆ°`token::symbol`ä¸­äº†ï¼Œå…¶å®è¿™é‡Œå¯ä»¥åšæ›´ç»†ç²’åº¦çš„åˆ’åˆ†ï¼Œæ¯”å¦‚åˆ’åˆ†`token::paren-open / token::paren-close`ç­‰ç­‰ï¼Œä½†è¿™é‡Œä¸åšç•™åˆ°paseré‡Œåˆ¤æ–­ä¹Ÿæ˜¯å¯ä»¥çš„

å®ƒçš„è¾“å…¥è¾“å‡ºæ˜¯è¿™æ ·çš„ï¼š

```lisp
(import (lexer))

(define code "let a = 2 * (1 + 3)")
(printf "~s" (scan code))

OUTPUT:

(#[#{token::keyword ettq95xxtz6ic726sbbnaqs44-7} let] #[#{token::ident ettq95xxtz6ic726sbbnaqs44-8} a] #[#{token::symbol ettq95xxtz6ic726sbbnaqs44-9} "="] #[#{token::number ettq95xxtz6ic726sbbnaqs44-10} 2] #[#{token::symbol ettq95xxtz6ic726sbbnaqs44-9} "*"] #[#{token::symbol ettq95xxtz6ic726sbbnaqs44-9} "("] #[#{token::number ettq95xxtz6ic726sbbnaqs44-10} 1] #[#{token::symbol ettq95xxtz6ic726sbbnaqs44-9} "+"] #[#{token::number ettq95xxtz6ic726sbbnaqs44-10} 3] #[#{token::symbol ettq95xxtz6ic726sbbnaqs44-9} ")"] #[#{token::endline ettq95xxtz6ic726sbbnaqs44-11}] #[#{token::eof ettq95xxtz6ic726sbbnaqs44-12}])
```

**Parser**è´Ÿè´£è§£æLexerçš„è¾“å‡ºï¼Œä¹Ÿå°±æ˜¯æ¥å—tokenæµä¸ºè¾“å…¥ï¼Œä»¥endlineä¸ºåˆ†å‰²è§£ææˆASTï¼Œæœ€åçš„è¾“å‡ºæ˜¯æ¯æ¡è¯­å¥çš„AST

åƒè¿™æ ·ï¼š

```lisp
(import (parse))
(import (lexer))
(import (ast))

(define code "let a = 2 * (1 + 3);")
(define t (scan code))
(define a (parse t))

(printf "~s" a)


OUTPUT:

(#[#{ast::define daqf9vsq5uvx5qezt929ps0q9-7} a (#[#{ast::* daqf9vsq5uvx5qezt929ps0q9-8} #[#{token::number daqf9vsq5uvx5qezt929ps0q9-9} 2] #[#{ast::+ daqf9vsq5uvx5qezt929ps0q9-10} #[#{token::number daqf9vsq5uvx5qezt929ps0q9-9} 1] #[#{token::number daqf9vsq5uvx5qezt929ps0q9-9} 3]]])])
```

è¿™ä¸ªå…¶å®ä¹Ÿå¾ˆç®€å•ï¼Œå”¯ä¸€çš„éš¾ç‚¹æ˜¯éœ€è¦è®¾è®¡å¥½æ¯ä¸€æ¡åˆ†æ”¯ï¼Œå°½å¯èƒ½å¤ç”¨ä»£ç ï¼ˆå‰æœŸæˆ‘æ²¡æœ‰ä»”ç»†æ–Ÿé…Œï¼Œå¯¼è‡´ä»£ç é€»è¾‘åˆ†æ”¯æœ‰å†—ä½™ï¼Œä¸å¤Ÿå®Œå–„ï¼‰

**Interpreter**æ¥å—ASTä¸ºè¾“å…¥ï¼Œè§£é‡Šæ‰§è¡Œå³å¯ï¼Œè§£é‡Šæ‰§è¡Œçš„è¿‡ç¨‹æ˜¯é‡ç‚¹ï¼Œåé¢è®²

### Lexical scoping

lexical scopingç›¸å¯¹äºdynamic scopingï¼ŒåŒºåˆ«åœ¨äºæ•è·è‡ªç”±å˜é‡æ—¶çš„è¡Œä¸º

lexical scopingåœ¨å‡½æ•°è°ƒç”¨æ—¶ä»å‡½æ•°å®šä¹‰å¤„çš„scopeè·å–å˜é‡ï¼Œè€Œdynamic scopingåˆ™ä»å‡½æ•°çš„è°ƒç”¨æ ˆå¾€ä¸Šæ•è·å˜é‡

```
A = 1

func foo() {
	print A
}

func bar() {
	A = 5
	foo()
}
```

å½“è°ƒç”¨baræ—¶ï¼Œlexical scopingä¼šè¾“å‡º1ï¼Œè€Œdynamic scopingä¼šè¾“å‡º5

ä¸ºäº†å®ç°lexical scopingï¼Œéœ€è¦å°†å‡½æ•°å®šä¹‰å¤„çš„ç¯å¢ƒä¿å­˜åœ¨å‡½æ•°å¯¹è±¡é‡Œï¼Œä¹Ÿå°±æ˜¯closureï¼Œè€Œå‡½æ•°è°ƒç”¨æ—¶çš„è‡ªç”±å˜é‡ï¼Œåº”å½“ä»å½“å‰å‡½æ•°çš„é—­åŒ…ä¸­è·å–

å½“æ‰©å±•ç¯å¢ƒå½¢æˆæ–°ä½œç”¨åŸŸæ—¶åªéœ€è¦ä»æ—§ä½œç”¨åŸŸæ‰©å±•å³å¯ï¼Œè€Œä¸€ä¸ªç¯å¢ƒåªä¼šæ‰©å±•è‡ªä¸€ä¸ªç¯å¢ƒï¼Œæ‰€ä»¥æ‰€æœ‰ç¯å¢ƒå…¶å®å¯ä»¥è¡¨ç¤ºä¸ºä¸€ä¸ªæ ‘å½¢ç»“æ„

```
               GLOBAL-ENV
              /          \
             ENV-0      ENV-1
           /
         ENV-2
```

è€Œé’ˆå¯¹è¿™æ£µæ ‘çš„æŸ¥è¯¢æ“ä½œåªä¼šä»å¶å‘æ ¹ï¼Œæ‰€ä»¥åªéœ€è¦ç”¨ä¸€ä¸ªåˆ—è¡¨ä¿å­˜æ‰€æœ‰çš„èŠ‚ç‚¹ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä¸­ä¿å­˜çˆ¶èŠ‚ç‚¹çš„ç´¢å¼•å³å¯

`env.ss`ä¸­å®šä¹‰äº†envçš„ç›¸å…³æ“ä½œ

```lisp
(define-record-type env (fields vars ref))

(define-syntax new-env
  (syntax-rules ()
    ((_ all-env)
      (define env (make-env (make-eq-hashtable) 'null))
      (set! all-env (append all-env `(,env)))
      env)))

(define-syntax ext-env
  (syntax-rules ()
    ((_ ref-env all-env)
      (define env (make-env (make-eq-hashtable) ref))
      (set! all-env (append all-env `(,env))))))

(define-syntax env-set!
  (syntax-rules ()
    ((_ env-index name val all-env)
      (let ((value (hashtable-ref 
                    (env-vars 
                      (list-ref all-env env-index)) 
                    name 'null)))
        (cond
          ((eq? value 'null)
          (let ((ref (env-ref (list-ref all-env env-index))))
            (cond
              ((eq? 'null ref) (halt "Undefined"))
              (else (let loop ((env (list-ref all-env ref)))
                (define h (env-vars env))
                (define value (hashtable-ref h name 'null))
                (case value
                  ('null (loop (list-ref all-env (env-ref env))))
                  (else
                    (hashtable-set! h name val))))))))
          (else (hashtable-set! 
                  (env-vars 
                    (list-ref all-env env-index) 
                    name val))))))))

(define env-lookup
  (lambda (env-index name all-env)
    (define env (list-ref all-env env-index))
    (let ((value (hashtable-ref 
                    (env-vars env) 
                    name 'null)))
      (cond
        ((eq? value 'null)
          (let ((ref (env-ref env)))
            (cond
              ((eq? 'null ref) 'null)
              (else (env-lookup ref name all-env)))))
        (else value)))))
```

è¿™é‡Œçš„`new-env`, `ext-env`, `env-set!`ä¸ºä»€ä¹ˆæˆ‘è¦ç”¨å®è€Œä¸æ˜¯å‡½æ•°ï¼Œæˆ‘çŒœä½ è‚¯å®šæ˜ç™½

### immutableå®ç°mutableçš„é—®é¢˜

ä¸ºä»€ä¹ˆä¼šæœ‰è¿™ä¸ªé—®é¢˜ï¼Ÿå‡å¦‚åªéœ€è¦å®ç°å‡½æ•°å¼æ•°æ®ç»“æ„ï¼ˆæ¯”å¦‚ç”¨Schemeå®ç°Schemeï¼‰ï¼Œé‚£ä¹ˆå°±ä¸éœ€è¦ä¸Šä¸€æ¡é‡Œçš„ä¸‰ä¸ªå®äº†

### æ­£åˆ™åºå’Œåº”ç”¨åº

è™½ç„¶Schemeæ˜¯ä¸ªè§£é‡Šå‹è¯­è¨€ï¼Œä½†å®ƒçš„å®ä¹Ÿä¸å¯ä»¥é€’å½’

å®é™…ç­‰åŒäºç¼–è¯‘æœŸæ›¿æ¢ï¼Œå³å…ˆæ‰©å±•åæ±‚å€¼ã€‚æ›´ä½³çš„è§£é‡Šæ˜¯å®æ˜¯æ­£åˆ™åºï¼Œè€Œå‡½æ•°æ˜¯åº”ç”¨åº

```lisp
(define-syntax foo
  (syntax-rules ()
    ((_ lst)
     (if (null? lst)
       'end
       (begin
         (printf "~s\n" (car lst))
         (foo (cdr lst)))))))


(define lst '(1 2 3 4 5))
(foo lst)
```